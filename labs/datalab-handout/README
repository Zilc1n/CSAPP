
> “这文件到底让我干啥？哪些规则？怎么交作业？”

下面我帮你 **总结这份文件的核心内容**，中英文对照，一目了然。

---

# ✅ **CS\:APP Data Lab 总结 (bits.c)**

---

## 📝 文件作用 (What’s this file for?)

这就是你的作业文件，名字叫：

```
bits.c
```

你需要在里面 **写函数实现**。
每道题就是一个函数，要求：

* 用指定的 **位运算** 完成
* 不许用 if、for、while（除浮点题）
* 不许用大的常数，比如 0xffffffff
* 不许调用别的函数
* 不许用数组、结构体、联合体
* 不许写宏
* 不许类型转换（cast）
* 浮点题除外，有些规则放宽

**→ 最终你要交这个文件给老师。**

> This is the file you hand in. You have to implement the functions in it according to strict rules.

---

## ✅ 整数题 (Integer Coding Rules)

你能用的操作：

* **整型常数**：只能用 0\~255 (0xFF)
* **一元运算**：`~`  `!`
* **二元运算**：`&`  `^`  `|`  `+`  `<<`  `>>`

禁止：

* if, while, for, switch
* 函数调用
* 定义宏
* 数组、struct、union
* 逻辑运算符 &&、||、-、三目运算符 ?: 等
* 类型转换

例子：

```c
int pow2plus1(int x) {
    /* Compute 2^x + 1 using shift */
    return (1 << x) + 1;
}
```

---

## ✅ 浮点题 (Floating-Point Coding Rules)

对浮点题，规则宽松一些：

* 可以用 **if / while / for**
* 可以用 unsigned、int
* 可以用所有逻辑、算术运算
* 可以用大常数
* 仍然禁止：

  * 函数调用
  * 数组、struct、union
  * 浮点类型 float / double / long double
  * 浮点常数（比如 1.0f）

浮点数据都以 **unsigned int** 存储。例如：

* `float f` → 存在 `unsigned uf` 里
* 需要手写 bit-level 操作

例如：

```c
unsigned floatScale2(unsigned uf) {
    // 不允许写 float f = ...，都必须用位运算处理
    return ...;
}
```

---

## ✅ 工具 (Tools)

* 用 `dlc` 检查：

  > 检测语法、运算符个数
* 用 `btest` 检查正确性：

  > 跑测试
* 用 `BDD checker` 检查逻辑等价：

  > 严格验证所有输入

---

## ✅ 常见小技巧

比如整数题：

* 取相反数：`~x + 1` → -x
* 用移位算乘除：

  * x << n = x × 2^n
  * x >> n = x ÷ 2^n
* 检测 x 是否为 0：

  ```c
  !x
  ```
* 检测某些 bit 是否全为 1：

  ```c
  (x & MASK) ^ MASK
  ```

浮点题：

* 分离 sign, exponent, fraction
* exponent 全 1 → NaN 或 INF
* exponent 全 0 → Denorm
* 不能用 float 类型
* 合成浮点数：

  ```c
  return sign | (exp << 23) | frac;
  ```

---

## ✅ 文件结构

你的文件大概长这样：

```c
/* 函数头注释 */
int bitXor(int x, int y) {
    return ...;
}
```

比如：

```c
/*
 * bitXor - x^y using only ~ and &
 */
int bitXor(int x, int y) {
    return ~(~x & ~y) & ~(x & y);
}
```

---

## ✅ 操作上限

每道题后面写了：

```
Max ops: 14
```

意思：

> 你最多用 14 个运算符 (比如 \~, &, << 等)

`dlc` 会检查这个限制。

---

## ✅ 提交注意

* 千万别加 `#include <stdio.h>`
* 不要定义 main
* 不要写 printf 除了你调试用（也会警告）

---


> 这就是 Data Lab，你要用位运算写出所有题目，不能用 if、循环，也不能用 float 类型，最后交这一个文件。



***********************
The CS:APP Data Lab
Directions to Students
***********************

Your goal is to modify your copy of bits.c so that it passes all the
tests in btest without violating any of the coding guidelines.


*********
0. Files:
*********

Makefile	- Makes btest, fshow, and ishow
README		- This file
bits.c		- The file you will be modifying and handing in
bits.h		- Header file
btest.c		- The main btest program
  btest.h	- Used to build btest
  decl.c	- Used to build btest
  tests.c       - Used to build btest
  tests-header.c- Used to build btest
dlc*		- Rule checking compiler binary (data lab compiler)	 
driver.pl*	- Driver program that uses btest and dlc to autograde bits.c
Driverhdrs.pm   - Header file for optional "Beat the Prof" contest
fshow.c		- Utility for examining floating-point representations
ishow.c		- Utility for examining integer representations

***********************************************************
1. Modifying bits.c and checking it for compliance with dlc
***********************************************************

IMPORTANT: Carefully read the instructions in the bits.c file before
you start. These give the coding rules that you will need to follow if
you want full credit.

Use the dlc compiler (./dlc) to automatically check your version of
bits.c for compliance with the coding guidelines:

       unix> ./dlc bits.c

dlc returns silently if there are no problems with your code.
Otherwise it prints messages that flag any problems.  Running dlc with
the -e switch:

    	unix> ./dlc -e bits.c  

causes dlc to print counts of the number of operators used by each function.

Once you have a legal solution, you can test it for correctness using
the ./btest program.

*********************
2. Testing with btest
*********************

The Makefile in this directory compiles your version of bits.c with
additional code to create a program (or test harness) named btest.

To compile and run the btest program, type:

    unix> make btest
    unix> ./btest [optional cmd line args]

You will need to recompile btest each time you change your bits.c
program. When moving from one platform to another, you will want to
get rid of the old version of btest and generate a new one.  Use the
commands:

    unix> make clean
    unix> make btest

Btest tests your code for correctness by running millions of test
cases on each function.  It tests wide swaths around well known corner
cases such as Tmin and zero for integer puzzles, and zero, inf, and
the boundary between denormalized and normalized numbers for floating
point puzzles. When btest detects an error in one of your functions,
it prints out the test that failed, the incorrect result, and the
expected result, and then terminates the testing for that function.

Here are the command line options for btest:

  unix> ./btest -h
  Usage: ./btest [-hg] [-r <n>] [-f <name> [-1|-2|-3 <val>]*] [-T <time limit>]
    -1 <val>  Specify first function argument
    -2 <val>  Specify second function argument
    -3 <val>  Specify third function argument
    -f <name> Test only the named function
    -g        Format output for autograding with no error messages
    -h        Print this message
    -r <n>    Give uniform weight of n for all problems
    -T <lim>  Set timeout limit to lim

Examples:

  Test all functions for correctness and print out error messages:
  unix> ./btest

  Test all functions in a compact form with no error messages:
  unix> ./btest -g

  Test function foo for correctness:
  unix> ./btest -f foo

  Test function foo for correctness with specific arguments:
  unix> ./btest -f foo -1 27 -2 0xf

Btest does not check your code for compliance with the coding
guidelines.  Use dlc to do that.

*******************
3. Helper Programs
*******************

We have included the ishow and fshow programs to help you decipher
integer and floating point representations respectively. Each takes a
single decimal or hex number as an argument. To build them type:

    unix> make

Example usages:

    unix> ./ishow 0x27
    Hex = 0x00000027,	Signed = 39,	Unsigned = 39

    unix> ./ishow 27
    Hex = 0x0000001b,	Signed = 27,	Unsigned = 27

    unix> ./fshow 0x15213243
    Floating point value 3.255334057e-26
    Bit Representation 0x15213243, sign = 0, exponent = 0x2a, fraction = 0x213243
    Normalized.  +1.2593463659 X 2^(-85)

    linux> ./fshow 15213243
    Floating point value 2.131829405e-38
    Bit Representation 0x00e822bb, sign = 0, exponent = 0x01, fraction = 0x6822bb
    Normalized.  +1.8135598898 X 2^(-126)



